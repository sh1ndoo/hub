### Оглавление
1.  [[Конспект по Docker#Введение и проблемы ручного развертывания|Введение и проблемы ручного развертывания]]
2.  [[Конспект по Docker#Docker как решение: образы и контейнеры|Docker как решение: образы и контейнеры]]
3.  [[Конспект по Docker#Компоненты Docker|Компоненты Docker]]
4.  [[Конспект по Docker#Установка Docker|Установка Docker]]
    *   [[Конспект по Docker#Установка на Mac|Установка на Mac]]
    *   [[Конспект по Docker#Установка на Linux|Установка на Linux]]
    *   [[Конспект по Docker#Установка на Windows|Установка на Windows]]
5.  [[Конспект по Docker#Основные команды Docker: работа с образами и контейнерами|Основные команды Docker: работа с образами и контейнерами]]
    *   [[Конспект по Docker#Загрузка образов (docker pull)|Загрузка образов (docker pull)]]
    *   [[Конспект по Docker#Просмотр образов (docker images)|Просмотр образов (docker images)]]
    *   [[Конспект по Docker#Запуск контейнеров (docker run)|Запуск контейнеров (docker run)]]
    *   [[Конспект по Docker#Просмотр контейнеров (docker ps)|Просмотр контейнеров (docker ps)]]
    *   [[Конспект по Docker#Запуск существующих контейнеров (docker start)|Запуск существующих контейнеров (docker start)]]
    *   [[Конспект по Docker#Остановка контейнеров (docker stop, docker kill)|Остановка контейнеров (docker stop, docker kill)]]
    *   [[Конспект по Docker#Удаление контейнеров и образов (docker rm, docker rmi, docker container prune)|Удаление контейнеров и образов (docker rm, docker rmi, docker container prune)]]
6.  [[Конспект по Docker#Создание собственных образов (Dockerfile)|Создание собственных образов (Dockerfile)]]
    *   [[Конспект по Docker#Основные команды Dockerfile (FROM, WORKDIR, COPY, CMD, ENV, RUN)|Основные команды Dockerfile (FROM, WORKDIR, COPY, CMD, ENV, RUN)]]
    *   [[Конспект по Docker#Сборка образа (docker build)|Сборка образа (docker build)]]
    *   [[Конспект по Docker#Работа с зависимостями (requirements.txt)|Работа с зависимостями (requirements.txt)]]
    *   [[Конспект по Docker#Команды CMD и ENTRYPOINT|Команды CMD и ENTRYPOINT]]
    * [[Конспект по Docker#Дополнительные полезные команды: stats, exec, logs, commit|Дополнительные полезные команды: stats, exec, logs, commit]]
    *   [[Конспект по Docker#Очистка кэша построения (docker builder prune)|Очистка кэша построения (docker builder prune)]]
7.  [[Конспект по Docker#Расширенные команды Docker и фильтрация|Расширенные команды Docker и фильтрация]]
    *   [[Конспект по Docker#Фильтрация контейнеров (docker ps -f)|Фильтрация контейнеров (docker ps -f)]]
    *   [[Конспект по Docker#Комбинирование команд|Комбинирование команд]]
    *   [[Конспект по Docker#Фильтрация и удаление образов|Фильтрация и удаление образов]]
8.  [[Конспект по Docker#Работа с сетью в Docker|Работа с сетью в Docker]]
    *   [[Конспект по Docker#Открытие портов (-p, -P)|Открытие портов (-p, -P)]]
    *   [[Конспект по Docker#Команда EXPOSE|Команда EXPOSE]]
    *   [[Конспект по Docker#Создание нового пользователя в контейнере|Создание нового пользователя в контейнере]]
9.  [[Конспект по Docker#Работа с томами (Volumes)|Работа с томами (Volumes)]]
    *   [[Конспект по Docker#Способы монтирования томов|Способы монтирования томов]]
    *   [[Конспект по Docker#Монтирование каталог к каталогу|Монтирование каталог к каталогу]]
    *   [[Конспект по Docker#Монтирование тома по имени|Монтирование тома по имени]]
    *   [[Конспект по Docker#Монтирование безымянных томов (команда VOLUME)|Монтирование безымянных томов (команда VOLUME)]]
10. [[Конспект по Docker#Микросервисная архитектура с Docker|Микросервисная архитектура с Docker]]
    *   [[Конспект по Docker#Создание пользовательской сети (docker network create)|Создание пользовательской сети (docker network create)]]
    *   [[Конспект по Docker#Связывание контейнеров (--link)|Связывание контейнеров (--link)]]
11. [[Конспект по Docker#Docker Compose: оркестрация контейнеров|Docker Compose: оркестрация контейнеров]]
    *   [[Конспект по Docker#Файл compose.yml: секции services, networks, volumes|Файл compose.yml: секции services, networks, volumes]]
    *   [[Конспект по Docker#Основные команды (docker compose up, down, build)|Основные команды (docker compose up, down, build)]]
    *   [[Конспект по Docker#Переменные окружения (.env файл)|Переменные окружения (.env файл)]]
12. [[Конспект по Docker#Развертывание Django-приложения с Docker Compose|Развертывание Django-приложения с Docker Compose]]
    *   [[Конспект по Docker#Настройка Nginx и Gunicorn|Настройка Nginx и Gunicorn]]
13. [[Конспект по Docker#Развертывание на реальном сервере и настройка HTTPS|Развертывание на реальном сервере и настройка HTTPS]]
    *   [[Конспект по Docker#Установка Docker на сервер (Ubuntu)|Установка Docker на сервер (Ubuntu)]]
    *   [[Конспект по Docker#Перенос проекта и запуск|Перенос проекта и запуск]]
    *   [[Конспект по Docker#Настройка HTTPS с Certbot|Настройка HTTPS с Certbot]]

---

### Введение и проблемы ручного развертывания
Ручное развертывание проектов на серверах сопряжено с рисками и сложностями:
*   Различия в ОС и окружении между локальной машиной и сервером.
*   Необходимость повторной установки и настройки зависимостей на каждом сервере.
*   Усложнение при масштабировании (добавлении новых серверов).
*   Трудности при обновлении проекта на множестве серверов.

Виртуальные машины (ВМ) частично решали проблему, позволяя воспроизвести окружение, но имели недостатки:
*   Требовали установки и настройки самой ВМ.
*   Захватывали фиксированный объем ресурсов.
*   Снижали производительность из-за наслоения ОС.

### Docker как решение: образы и контейнеры
**Docker** (появился в 2013 г.) – технология, позволяющая изолированно запускать программы в своих ОС (контейнерах), используя ядро ОС хост-сервера напрямую.
*   **Преимущества Docker перед ВМ:**
    *   Быстрое выполнение программ.
    *   Меньший размер ОС в контейнере.
    *   Эффективное использование ресурсов (контейнер – отдельный процесс, потребляет ресурсы по мере необходимости).
*   **Образ (image):** Файл со всей информацией для создания и запуска изолированной оболочки (контейнера) с программными компонентами. Состоит из слоев:
    *   Облегченная версия ОС.
    *   Интерпретатор ЯП.
    *   Библиотеки.
    *   Файлы проекта.
    *   Настройки.
    *   Команда запуска приложения.
*   **Контейнер (container):** Запущенный экземпляр образа. Изолированная среда со своей ОС, утилитами, библиотеками и проектом, работающая как отдельный процесс. Данные, генерируемые программой, хранятся внутри контейнера (если не используются тома).
*   На основе одного образа можно создавать множество независимых контейнеров.
*   **Docker Hub:** Облачный сервис для хранения и распространения образов.

### Компоненты Docker
*   **Docker Engine (движок Docker):**
    *   **Docker daemon (dockerd):** Фоновый процесс, управляющий образами, контейнерами, сетями, томами. Принимает команды от Docker клиента.
    *   **Docker client (docker CLI):** Интерфейс командной строки для взаимодействия с Docker daemon.
*   **Docker Desktop:** Приложение, включающее Docker Engine, графический интерфейс и все необходимые компоненты. Для Windows и Mac часто единственный вариант установки. Работает через ВМ с Linux.

### Установка Docker
*   Скачивание с официального сайта: [https://www.docker.com](https://www.docker.com)
*   #### Установка на Mac
    Выбор установщика в зависимости от процессора (Intel/Apple silicon). Может потребоваться установка Rosetta.
*   #### Установка на Linux
    Возможна установка Docker Desktop (работает в изолированной оболочке) или отдельных компонентов Docker Engine и Docker Compose (потенциально быстрее).
*   #### Установка на Windows
    Рекомендуется использовать WSL (Windows Subsystem for Linux) версии 2.
    *   Проверка наличия WSL: `wsl.exe -l -v`.
    *   Установка WSL: `wsl --install` или `wsl --update`.
    *   Убедиться, что включен компонент "Подсистема Windows для Linux".
    *   Может потребоваться активация виртуализации в BIOS.
    *   После установки Docker Desktop, команда `docker` должна быть доступна в терминале.

### Основные команды Docker: работа с образами и контейнерами

#### Загрузка образов (docker pull)
*   `docker pull <имя_образа>:<тег>`: Скачивает образ из Docker Hub.
    *   Пример: `docker pull hello-world` (по умолчанию используется тег `latest`).

#### Просмотр образов (docker images)
*   `docker images`: Отображает список скачанных образов с информацией (репозиторий, тег, ID, время создания, размер).
    *   **Репозиторий:** Имя группы образов (например, `python`).
    *   **Тег:** Конкретная версия или конфигурация образа в репозитории (например, `3.12-alpine`, `latest`).

#### Запуск контейнеров (docker run)
*   `docker run <имя_образа>:<тег>`: Создает и запускает новый контейнер на основе образа.
    *   Если тег не указан, используется `latest`.
    *   `--name <имя_контейнера>`: Задает имя контейнеру. Имена должны быть уникальны.
    *   `-it`: (Интерактивный режим + терминал) `-i` (interactive) + `-t` (pseudo-TTY). Позволяет взаимодействовать с контейнером.
    *   `--rm`: Автоматически удаляет контейнер после его завершения.
    * `-p`: Настройка портов
    * `--link`: Связывание названий контейнеров
    * `--network`: Используемая сеть

#### Просмотр контейнеров (docker ps)
*   `docker ps`: Отображает только запущенные контейнеры.
*   `docker ps -a`: Отображает все контейнеры (включая остановленные).
    *   Информация: ID контейнера, образ, команда запуска, время создания, статус, порты, имя.

#### Запуск существующих контейнеров (docker start)
*   `docker start <имя_или_ID_контейнера>`: Запускает существующий остановленный контейнер.
    *   `-i`: Запуск в интерактивном режиме для привязки к стандартным потокам ввода/вывода.

#### Остановка контейнеров (docker stop, docker kill)
*   `docker stop <имя_или_ID_контейнера>`: Штатно останавливает работающий контейнер.
*   `docker kill <имя_или_ID_контейнера>`: Принудительно завершает контейнер (если завис).

#### Удаление контейнеров и образов (docker rm, docker rmi, docker container prune)
*   `docker rm <имя_или_ID_контейнера>`: Удаляет остановленный контейнер.
	* Флаг `-f` сначала останавливает а после удаляет контейнер
*   `docker container prune`: Удаляет все остановленные контейнеры.
*   `docker rmi <имя_образа>:<тег>` или `docker rmi <ID_образа>`: Удаляет образ.
    *   Образ можно удалить, только если с ним не связано ни одного контейнера.
    *   Если тег не указан, используется `latest`.

### Создание собственных образов (Dockerfile)
**Dockerfile:** Текстовый файл с инструкциями для сборки образа. Располагается в корне проекта.

#### Основные команды Dockerfile (FROM, WORKDIR, COPY, CMD, ENV, RUN)
*   `FROM <базовый_образ>:<тег>`: Определяет базовый образ, на основе которого строится новый. Первая команда в Dockerfile.
*   `WORKDIR /<путь_к_каталогу>`: Устанавливает рабочий каталог внутри образа для последующих команд (`COPY`, `RUN`, `CMD`, `ENTRYPOINT`). Создает каталог, если его нет.
*   `COPY <источник_на_хосте> <пункт_назначения_в_образе>`: Копирует файлы/каталоги с хост-машины в образ.
    *   Пример: `COPY . .` (копировать все из текущего каталога хоста в текущий рабочий каталог образа).
*   `RUN <команда>`: Выполняет команду в командной оболочке внутри образа во время его сборки (например, установка пакетов). Каждая `RUN` создает новый слой.
*   `CMD ["исполняемый_файл", "параметр1", "параметр2"]`: Задает команду по умолчанию, которая будет выполнена при запуске контейнера из образа. Может быть переопределена при запуске контейнера.
*   `ENV <ключ>=<значение>`: Устанавливает переменные окружения.
    *   Пример: `ENV PYTHONUNBUFFERED=1` (отключает буферизацию вывода для Python).

#### Сборка образа (docker build)
*   `docker build <путь_к_контексту_сборки> -t <имя_образа>:<тег>`
    *   `<путь_к_контексту_сборки>`: Обычно `.` (текущий каталог, где лежит Dockerfile).
    *   `-t`: Задает имя и тег образу. Если тег не указан, используется `latest`.

#### Работа с зависимостями (requirements.txt)
*   Для Python-проектов зависимости выносятся в `requirements.txt`.
*   В Dockerfile:
    ```dockerfile
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    COPY . .
    ```
    *   Разделение `COPY` для `requirements.txt` и остального проекта оптимизирует кэширование слоев (слой с зависимостями пересобирается реже).
    *   `--no-cache-dir`: Опция `pip` для уменьшения размера образа.

#### Команды CMD и ENTRYPOINT
*   **CMD:** Определяет команду по умолчанию. Легко переопределяется при `docker run`.
*   **ENTRYPOINT:** Также определяет команду, но параметры, передаваемые при `docker run`, добавляются к `ENTRYPOINT`, а не заменяют его. Используется для создания "исполняемых" образов.

#### Дополнительные полезные команды: stats, exec, logs, commit

Помимо основных команд для управления жизненным циклом образов и контейнеров, Docker предоставляет ряд утилит для мониторинга, взаимодействия и сохранения состояния контейнеров.

##### docker stats

Команда docker stats отображает в реальном времени статистику использования ресурсов запущенными контейнерами. Это очень полезно для мониторинга производительности и потребления ресурсов.

- **Использование:** docker stats [имена_или_ID_контейнеров...]
    
    - Если имена или ID не указаны, отображается статистика по всем запущенным контейнерам.
        
- **Выводимая информация:**
    
    - CONTAINER ID и NAME: Идентификатор и имя контейнера.
        
    - CPU %: Процент использования CPU.
        
    - MEM USAGE / LIMIT: Используемая память / Лимит памяти.
        
    - MEM %: Процент использования памяти.
        
    - NET I/O: Сетевой ввод/вывод (получено/отправлено).
        
    - BLOCK I/O: Дисковый ввод/вывод (прочитано/записано).
        
    - PIDS: Количество процессов.
        

##### docker exec

Команда docker exec позволяет выполнить команду внутри уже запущенного контейнера. Это основной способ взаимодействия с процессами внутри контейнера без необходимости переподключения или пересоздания.

- **Использование:** docker exec [опции] <имя_или_ID_контейнера> <команда> [аргументы...]
    
- **Часто используемые опции:**
    
    - -i (--interactive): Оставляет STDIN открытым, даже если не подключен.
        
    - -t (--tty): Выделяет псевдо-терминал (TTY).
        
    - -d (--detach): Запускает команду в фоновом режиме.
        
    - -e <КЛЮЧ>=<ЗНАЧЕНИЕ>: Устанавливает переменные окружения для выполняемой команды.
        
    - -w <путь>: Устанавливает рабочий каталог для команды внутри контейнера.
        
- **Примеры:**
    
    - Запустить интерактивную оболочку bash в контейнере:
        
        ```
        docker exec -it my_container bash
        ```
        
    - Посмотреть список файлов в каталоге /app контейнера:
        
        ```
        docker exec my_container ls /app
        ```
        
    - Установить пакет внутри контейнера (если там есть менеджер пакетов):
        
        ```
        docker exec my_container apt-get update && apt-get install -y some-package
        ```
        
- **Ключевой момент:** docker exec запускает новый процесс в пространстве имен (namespaces) существующего контейнера.
    

##### docker logs

Команда docker logs извлекает логи (стандартный вывод STDOUT и стандартный вывод ошибок STDERR) указанного контейнера. Это основной способ отладки и мониторинга работы приложений внутри контейнеров.

- **Использование:** docker logs [опции] <имя_или_ID_контейнера>
    
- **Часто используемые опции:**
    
    - -f (--follow): Следовать за выводом логов в реальном времени (аналогично tail -f).
        
    - --tail <количество_строк>: Показать указанное количество последних строк лога (например, --tail 100).
        
    - --since <временная_метка_или_период>: Показать логи, начиная с указанного времени (например, --since "2023-10-26T10:00:00" или --since 10m для последних 10 минут).
        
    - --until <временная_метка_или_период>: Показать логи до указанного времени.
        
    - -t (--timestamps): Показать временные метки для каждой строки лога.
        
- **Пример:**
    
    ```
    docker logs -f --tail 50 my_app_container
    ```
    

##### docker commit

Команда docker commit создает новый образ из изменений, сделанных в файловой системе контейнера. По сути, она "замораживает" текущее состояние контейнера и сохраняет его как новый образ.

- **Использование:** docker commit [опции] <имя_или_ID_контейнера> [репозиторий[:тег]]
    
- **Часто используемые опции:**
    
    - -a (--author <строка>): Автор образа (например, "John Doe [john.doe@example.com](https://www.google.com/url?sa=E&q=mailto%3Ajohn.doe%40example.com)").
        
    - -m (--message <строка>): Сообщение коммита, описывающее изменения.
        
    - -p (--pause): Приостановить контейнер во время создания образа (по умолчанию true).
        
- **Пример:**
    
    ```
    docker commit -m "Installed custom package and configured app" -a "My Name" my_modified_container my_new_image:1.0
    ```
    
- **Когда использовать (и когда нет):**
    
    - **Полезно для:** Быстрого сохранения состояния после отладки или экспериментов; создания временного образа для переноса на другую машину.
        
    - **Не рекомендуется для:** Создания производственных образов. Для этого всегда следует использовать Dockerfile, так как он обеспечивает воспроизводимость, версионирование и прозрачность процесса сборки. Образы, созданные через docker commit, сложнее поддерживать и понимать, из чего они состоят ("черный ящик").

#### Очистка кэша построения (docker builder prune)
*   `docker builder prune`: Удаляет неиспользуемый кэш построения.
*   `docker builder prune -a`: Удаляет весь кэш построения.
*   `docker system prune`: Удаляет остановленные контейнеры, неиспользуемые сети, образы без ссылок и кэш построения.
*   `docker system prune -a`: То же, но удаляет все образы, с которыми не связан ни один контейнер, и весь кэш построения.

### Расширенные команды Docker и фильтрация

#### Фильтрация контейнеров (docker ps -f)
*   `docker ps -q`: Выводит только ID контейнеров.
*   `docker ps -f <критерий>=<значение>`: Фильтрует список контейнеров.
    *   `status=exited`: Завершенные контейнеры.
    *   `status=running`: Запущенные контейнеры.
    *   `exited=<код_завершения>`: Контейнеры, завершенные с определенным кодом.

#### Комбинирование команд
*   Использование вывода одной команды в другой: `docker <команда> $(docker <другая_команда>)`
    *   Пример: `docker stop $(docker ps -q)` (остановить все запущенные контейнеры).
    *   Пример: `docker rm $(docker ps -qf status=exited)` (удалить все остановленные контейнеры).

#### Фильтрация и удаление образов
*   `docker images -aq`: ID всех образов.
*   `docker images -f dangling=true`: "Висячие" образы (неиспользуемые слои).
*   `docker rmi $(docker images -qf dangling=true)`: Удаление "висячих" образов.
*   `docker image prune -a`: Удаление всех образов, не связанных с контейнерами.

### Работа с сетью в Docker
*   Docker создает свою внутреннюю изолированную сеть.
*   Для взаимодействия с хостом и внешней сетью нужно "пробрасывать" порты.

#### Открытие портов (-p, -P)
*   `-p <порт_хоста>:<порт_контейнера>`: Связывает порт хоста с портом контейнера.
    *   Пример: `docker run -p 8000:80 nginx` (порт 8000 хоста на порт 80 контейнера).
*   `-p <IP_хоста>:<порт_хоста>:<порт_контейнера>`: Связывает порт контейнера с конкретным IP и портом хоста.
    *   Пример: `docker run -p 127.0.0.1:8000:80 nginx`.
*   `-P` (заглавная): Автоматически связывает все *открытые* (EXPOSEd) порты контейнера со случайными свободными портами на хосте.
*   `docker port <имя_контейнера>`: Показывает маппинг портов для контейнера.
*   `docker container inspect <имя_контейнера>`: Подробная информация о контейнере, включая сетевые настройки и IP-адрес во внутренней сети Docker.

#### Команда EXPOSE
*   `EXPOSE <порт1> <порт2> ...`: Инструкция в Dockerfile, информирующая о том, какие порты приложение внутри контейнера слушает. **Не публикует порты автоматически**, но используется флагом `-P`.

#### Создание нового пользователя в контейнере
*   Для безопасности лучше запускать процессы в контейнере от имени непривилегированного пользователя.
*   В Dockerfile (для Linux-образов):
    ```dockerfile
    RUN groupadd -r <имя_группы> && useradd -r -g <имя_группы> <имя_пользователя>
    # ... другие команды ...
    USER <имя_пользователя>
    CMD ["команда_запуска"]
    ```

### Работа с томами (Volumes)
**Тома (volumes):** Механизм для сохранения данных за пределами жизненного цикла контейнера, обеспечивая их персистентность и возможность совместного использования.

#### Способы монтирования томов
1.  **Bind mounts (связывание каталогов):** Каталог хоста <-> каталог контейнера.
2.  **Именованные тома:** Управляются Docker, хранятся в специальной области файловой системы хоста.
3.  **Безымянные (анонимные) тома:** Управляются Docker, имена генерируются автоматически.

#### Монтирование каталог к каталогу
*   `docker run -v <полный_путь_на_хосте>:<путь_в_контейнере> ...`
    *   `${PWD}` (или `$(pwd)`) можно использовать для указания текущего каталога хоста.
    *   При пустой папке на хосте данные из контейнера могут копироваться в нее.
    *   Изменения на хосте отражаются в контейнере и наоборот.
    *   **Недостаток:** Зависимость от структуры каталогов хоста, снижает переносимость.

#### Монтирование тома по имени
*   `docker run -v <имя_тома>:<путь_в_контейнере> ...`
    *   Если том с таким именем не существует, Docker создает его.
    *   Если созданный том пуст, данные из указанного каталога контейнера копируются в том.
    *   Если том уже существует и содержит данные, копирования не происходит, контейнер использует данные из тома.
    *   `docker volume ls`: Список томов.
    *   `docker volume inspect <имя_тома>`: Информация о томе.
    *   `docker volume rm <имя_тома>`: Удаление тома.
    *   `docker volume create <имя_тома>`: Создание тома.
    *   **Преимущество:** Управляется Docker, сохраняет переносимость.

#### Монтирование безымянных томов (команда VOLUME)
*   `docker run -v <путь_в_контейнере> ...`: Docker создает том с автоматически сгенерированным именем.
*   Используются для временного хранения или совместного использования данных.
*   При каждом запуске без указания существующего тома создается новый.
*   `docker rm -v <имя_контейнера>`: Удаляет контейнер вместе со связанными с ним безымянными томами.
*   **Инструкция `VOLUME` в Dockerfile:**
    *   `VOLUME ["<путь_в_контейнере>"]`
    *   Автоматически создает безымянный том при запуске контейнера из образа, если не указано другое монтирование для этого пути.
    *   Команды в Dockerfile *после* `VOLUME`, обращающиеся к этому каталогу, будут применяться к тому на момент сборки (что обычно бессмысленно, так как том создается при запуске контейнера).

### Микросервисная архитектура с Docker
*   Разбиение крупного приложения на независимо работающие модули (микросервисы), каждый в своем контейнере.
*   Взаимодействие по сети.
*   **Преимущества:** Независимая разработка и развертывание модулей, разные технологии для разных модулей, упрощенная замена модулей.
*   **Недостатки:** Скорость обмена данными ниже, чем у монолита.

#### Создание пользовательской сети (docker network create)
*   `docker network ls`: Список сетей.
*   `docker network create <имя_сети>`: Создает новую пользовательскую сеть (по умолчанию типа `bridge`).
*   Контейнеры в одной пользовательской сети могут обращаться друг к другу по именам контейнеров.

#### Связывание контейнеров (--link)
*   `docker run --network <имя_сети> --link <имя_целевого_контейнера>:<алиас> ...`
    *   Создает алиас для доступа к целевому контейнеру внутри запускаемого контейнера.
    *   **Примечание:** `--link` считается устаревшим способом. Рекомендуется использовать пользовательские сети и обращение по именам контейнеров.

### Docker Compose: оркестрация контейнеров
**Docker Compose:** Инструмент для определения и запуска многоконтейнерных Docker-приложений. Использует YAML-файл для конфигурации сервисов.

#### Файл compose.yml: секции services, networks, volumes
*   Располагается в корне проекта.
*   **`version`:** (Устаревшее, но может встречаться) Версия синтаксиса файла.
*   **`services`:** Определяет контейнеры (сервисы) приложения.
    *   `<имя_сервиса>:`
        *   `image: <имя_образа>:<тег>`: Используемый образ.
        *   `build: <путь_к_контексту_сборки>`: Если образ нужно собрать из Dockerfile.
            *   Если `build` указан, `image` задает имя создаваемому образу.
        *   `container_name: <имя_контейнера>`: Имя создаваемого контейнера.
        *   `ports: ["<порт_хоста>:<порт_контейнера>"]`: Маппинг портов.
        *   `volumes: ["<том_или_путь_хоста>:<путь_в_контейнере>"]`: Монтирование томов.
        *   `environment: ["<ключ>=<значение>"]` или `VAR: value`: Переменные окружения.
        *   `env_file: ["<.env_файл>"]`: Путь к файлу с переменными окружения.
        *   `networks: ["<имя_сети>"]`: Сети, к которым подключается сервис.
        *   `links: ["<сервис>:<алиас>"]`: (Устаревшее) Связывание с другими сервисами.
        *   `depends_on: ["<сервис>"]`: Зависимости запуска (сервис запустится после указанных).
        *   `command: <команда_запуска>`: Переопределяет CMD образа.
        *   `restart: always` (или `on-failure`, `unless-stopped`): Политика перезапуска.
*   **`networks`:** Определяет пользовательские сети.
    *   `<имя_сети>:`
        *   `driver: bridge` (или другой драйвер).
*   **`volumes`:** Определяет именованные тома.
    *   `<имя_тома>:` (может быть пустым, если используется драйвер по умолчанию).

#### Основные команды (docker compose up, down, build)
*   `docker compose up`: Собирает (если нужно), создает и запускает контейнеры, определенные в `compose.yml`.
    *   `-d`: Запуск в фоновом (detached) режиме.
    *   `--build`: Принудительно пересобирает образы перед запуском.
*   `docker compose down`: Останавливает и удаляет контейнеры, сети (но не тома по умолчанию).
    *   `-v`: Удаляет также именованные тома, определенные в секции `volumes`.
*   `docker compose build`: Собирает образы для сервисов, у которых указана секция `build`.
*   `docker compose stop`: Останавливает сервисы.
*   `docker compose start`: Запускает остановленные сервисы.
*   `docker compose ps`: Показывает статус сервисов.
*   `docker compose logs <имя_сервиса>`: Показывает логи сервиса.
*   `docker compose exec <имя_сервиса> <команда>`: Выполняет команду внутри работающего контейнера сервиса.

#### Переменные окружения (.env файл)
*   Файл `.env` в том же каталоге, что и `compose.yml`, автоматически загружается Docker Compose.
*   Переменные из `.env` можно использовать в `compose.yml` через `${ПЕРЕМЕННАЯ}`.

### Развертывание Django-приложения с Docker Compose
Типичный стек: Django (Python), PostgreSQL (СУБД), Nginx (веб-сервер/прокси), Adminer (управление БД).

*   **PostgreSQL сервис:**
    *   Использует официальный образ.
    *   Задает переменные окружения (`POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD`).
    *   Монтирует именованный том для персистентности данных БД.
*   **Adminer сервис:**
    *   Использует официальный образ.
    *   Пробрасывает порт (например, `8080:8080`).
    *   Связывается с сервисом PostgreSQL.
*   **Django (web) сервис:**
    *   Собирается из Dockerfile.
        *   Dockerfile: базовый образ Python, установка зависимостей из `requirements.txt`, копирование проекта, создание пользователя, команда запуска (Gunicorn).
    *   `requirements.txt`: включает `django`, `psycopg2-binary` (для PostgreSQL), `gunicorn`, `gevent`.
    *   Использует переменные окружения из `.env` для настроек Django (`SECRET_KEY`, `ALLOWED_HOSTS`, настройки БД).
    *   Монтирует каталог проекта с хоста для разработки (чтобы изменения кода сразу отражались).
    *   Запускает Django через Gunicorn.
*   **Nginx сервис:**
    *   Использует официальный образ.
    *   Пробрасывает порт `80` (и `443` для HTTPS).
    *   Монтирует кастомный конфигурационный файл (например, `nginx/sitewomen.conf`).
    *   Монтирует каталоги со статикой (`static`) и медиа (`media`) из Django-приложения.
    *   Конфигурация Nginx: проксирует запросы к Gunicorn, отдает статику и медиа.

#### Настройка Nginx и Gunicorn
*   **Gunicorn:** WSGI HTTP сервер для Python. Запускает Django-приложение.
    *   Конфигурационный файл `gunicorn.py` (задается `bind` на `0.0.0.0:<порт>`, `workers`, `worker_class='gevent'`).
*   **Nginx:** Выступает как reverse proxy перед Gunicorn.
    *   Отдает статические файлы и медиа напрямую.
    *   Перенаправляет динамические запросы к Django (Gunicorn).
    *   Может обрабатывать SSL/TLS.

### Развертывание на реальном сервере и настройка HTTPS

#### Установка Docker на сервер (Ubuntu)
1.  Обновление пакетов: `apt update && apt upgrade -y`.
2.  Установка зависимостей: `apt install apt-transport-https ca-certificates curl software-properties-common -y`.
3.  Добавление GPG ключа Docker:
    ```bash
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    ```
4.  Добавление репозитория Docker:
    ```bash
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    ```
5.  Установка Docker Engine и Docker Compose plugin:
    ```bash
    apt update
    apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y
    ```
6.  Проверка статуса: `systemctl status docker`.

#### Перенос проекта и запуск
1.  Перенести проект на сервер (например, через `git clone` или `scp`).
2.  Настроить файл `.env` (например, `DJANGO_ALLOWED_HOSTS` указать домен сервера).
3.  Запустить проект: `docker compose up --build -d`.
4.  Выполнить миграции и загрузить данные (если нужно) внутри контейнера Django:
    ```bash
    docker compose exec <имя_django_сервиса> python manage.py migrate
    docker compose exec <имя_django_сервиса> python manage.py loaddata db.json
    ```

#### Настройка HTTPS с Certbot
*   **Certbot:** Инструмент для автоматического получения и установки SSL/TLS сертификатов от Let's Encrypt.
*   Добавление сервиса `certbot` в `compose.yml`:
    ```yaml
    services:
      # ... другие сервисы ...
      certbot:
        image: certbot/certbot
        volumes:
          - ./certbot/conf:/etc/letsencrypt # для хранения сертификатов
          - ./certbot/www:/var/www/certbot   # для webroot-проверки
        # команда для получения сертификата (замените email и домен)
        command: certonly --webroot --webroot-path=/var/www/certbot/ --email your_email@example.com --agree-tos --no-eff-email -d your_domain.com
        depends_on:
          - nginx # чтобы nginx был запущен для webroot-проверки
    ```
*   Модификация сервиса `nginx` в `compose.yml`:
    *   Добавить монтирование томов для `certbot`:
        ```yaml
        volumes:
          # ... другие тома ...
          - ./certbot/conf:/etc/letsencrypt
          - ./certbot/www:/var/www/certbot
        ```
    *   Добавить порт `443`:
        ```yaml
        ports:
          - "80:8088" # или порт, который слушает nginx
          - "443:443" # порт для https
        ```
*   Создание каталогов на хосте: `mkdir -p certbot/conf certbot/www`.
*   Модификация конфигурации Nginx (`nginx/sitewomen.conf`):
    *   Добавить location для `.well-known/acme-challenge` (необходимо для `certbot` при webroot-проверке):
        ```nginx
        server {
            listen 8088; # порт, который слушает nginx для http
            # ...
            location /.well-known/acme-challenge/ {
                root /var/www/certbot;
            }
            # ... (можно добавить редирект на https здесь, после получения сертификата)
        }
        ```
*   Первый запуск: `docker compose up --build`. Certbot должен получить сертификат.
*   Остановить: `docker compose down`.
*   Обновить конфигурацию Nginx для использования HTTPS и редиректа с HTTP:
    ```nginx
    server {
        listen 8088;
        server_name your_domain.com;
        # ... location для acme-challenge если нужно автоматическое обновление ...
        location / {
            return 301 https://$host$request_uri;
        }
    }

    server {
        listen 443 ssl;
        server_name your_domain.com;

        ssl_certificate /etc/letsencrypt/live/your_domain.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/your_domain.com/privkey.pem;

        # ... остальная конфигурация proxy_pass к Django, static, media ...
        location /adminer/ { # Пример прокси для Adminer
            proxy_pass http://adminer:8080; # имя сервиса adminer и его внутренний порт
        }
    }
    ```
*   Финальный запуск: `docker compose up --build -d`. Сайт должен быть доступен по HTTPS.