*   **Присваивание и Инициализация:**
    *   **Объявление:** `тип имя;` (например, `int count;`)
    *   **Присваивание:** `имя = значение;` (например, `count = 10;`)
    *   **Инициализация:** Объявление и присваивание в одной строке. `тип имя = значение;` (например, `double price = 99.9;`)
    *   **Множественное:** `int x = 1, y, z = 5;` (`x` и `z` инициализированы, `y` только объявлена).
    *   **Цепочечное присваивание:** `a = b = c = 0;` (присваивание справа налево).
    *   **Потеря точности:** При присваивании вещественного числа целочисленной переменной дробная часть отбрасывается (не округляется): `int i = 5.9; // i будет равно 5`.
*   **Суффиксы Литералов:** Указывают компилятору тип числового литерала.
    *   `f` или `F`: `float` (например, `10.0f`).
    *   `l` или `L`: `long int` или `long double` (например, `100L`, `3.14L`).
    *   `ll` или `LL`: `long long int` (например, `5000000000LL`).
    *   `u` или `U`: `unsigned` (можно комбинировать: `10UL`, `50ULL`).
*   **Присваивание символов:**
    *   Используются одинарные кавычки `''`.
    *   Тип `char` предназначен для хранения символов.
    *   Пример: `char grade = 'A';`, `char newline = '\n';`
*   **Буфер ввода (`stdin`):** При чтении со стандартного ввода (например, через `scanf`, `getchar`), непрочитанные символы (включая пробелы, `\n`) остаются в буфере и могут быть прочитаны следующими операциями ввода. Это частая причина неожиданного поведения при смешивании разных функций ввода.
*   **Арифметические операции:**
    *   **Типы операндов и результат:** Перед выполнением операции происходит "обычное арифметическое преобразование" (integer promotion и conversion to common type). Меньшие целочисленные типы (`char`, `short`) обычно повышаются до `int`. Если операнды разных типов, младший тип приводится к старшему (например, `int` к `float`, `float` к `double`).
    *   Примеры:
        *   `int` + `short` -> `int`
        *   `float` * `double` -> `double`
        *   `float` - `int` -> `float` (или `double` в зависимости от контекста)
        *   `int` / `int` -> `int` (целочисленное деление).
    *   **Операции:**
        *   `+` Сложение.
        *   `-` Вычитание.
        *   `*` Умножение.
        *   `/` Деление.
        *   `%` Остаток от деления (только для целочисленных типов).
            *   Знак результата совпадает со знаком левого операнда (в C99 и новее): `-10 % 3 = -1`, `-10 % -3 = -1`, `10 % -3 = 1`.
    *   **Инкремент `++` и Декремент `--`:**
        *   **Префиксная форма (`++count`, `--count`):** Сначала изменяет значение переменной, затем использует *новое* значение в выражении.
        *   **Постфиксная форма (`count++`, `count--`):** Сначала использует *старое* значение переменной в выражении, затем изменяет значение переменной.
*   **Приведение типов (Type Casting):**
    *   Явное преобразование значения одного типа в другой.
    *   Синтаксис: `(новый_тип)выражение`
    *   Пример (для получения вещественного результата деления):
        ```c
        int sum = 5;
        int count = 2;
        double average1 = (double)sum / count; // average1 = 2.5 (sum приводится к double)
        double average2 = sum / (double)count; // average2 = 2.5 (count приводится к double)
        double average3 = (double)sum / (double)count; // average3 = 2.5
        // Ошибка: double average4 = (double)(sum / count); // average4 = 2.0 (сначала целочисленное деление)
        ```
*   **Операции сравнения:** Возвращают `1` (истина) или `0` (ложь) (тип `int` в C, `bool` в C++).
    *   `==`: Равно.
    *   `!=`: Не равно.
    *   `<`: Меньше.
    *   `>`: Больше.
    *   `<=`: Меньше или равно.
    *   `>=`: Больше или равно.
*   **Подключение заголовочных файлов (`#include`):**
    *   `<stdio.h>`: Стандартный ввод/вывод (`printf`, `scanf`, `getchar`, `putchar`, etc.).
    *   `<stdbool.h>`: Тип `bool` и константы `true`, `false` (в C99 и новее; в C++ встроенный).
    *   `<math.h>`: Математические функции (`pow`, `sqrt`, `sin`, `cos`, etc.).
    *   `<stdlib.h>`: Общие утилиты, включая `rand`, `srand`, `malloc`, `free`, `exit`, etc.
    *   `<time.h>`: Функции для работы со временем (`time`, etc.).
*   **Логические операции:**
    *   **Битовые:** Работают с отдельными битами целочисленных операндов.
        *   `~`: Битовое НЕ (инверсия). `~0b1010 -> ...11110101`
        *   `|`: Битовое ИЛИ. `0b1010 | 0b1100 -> 0b1110`
        *   `&`: Битовое И. `0b1010 & 0b1100 -> 0b1000`
        *   `^`: Битовое исключающее ИЛИ (XOR). `0b1010 ^ 0b1100 -> 0b0110`
    *   **Логические (не битовые):** Работают с истинностью (0 - ложь, не 0 - истина) операндов. Возвращают `1` или `0`.
        *   `!`: Логическое НЕ. Приоритет 3 (высокий). `!0 -> 1`, `!5 -> 0`.
        *   `&&`: Логическое И (вычисляется лениво). Приоритет 2. `1 && 1 -> 1`, `1 && 0 -> 0`.
        *   `||`: Логическое ИЛИ (вычисляется лениво). Приоритет 1 (низкий). `0 || 1 -> 1`, `0 || 0 -> 0`.
*   **Сдвиговые битовые операции:**
    *   `<<`: Сдвиг влево. `x << n` эквивалентно `x * 2^n` (для неотрицательных `x`). Биты слева теряются, справа добавляются нули.
    *   `>>`: Сдвиг вправо. `x >> n` эквивалентно `x / 2^n` (целочисленное деление). Для `unsigned` типов слева добавляются нули. Для `signed` типов результат зависит от реализации (арифметический или логический сдвиг).
    *   Пример:
        ```c
        unsigned char x = 40; // 00101000
        x = x >> 1;          // 00010100 (20)
        x = x << 2;          // 01010000 (80) 
        ```
*   **Циклы:**
    *   **`while` (Цикл с предусловием):**
        ```c
        while (условие) {
            // Операторы тела цикла
        }
        // Если условие ложно с самого начала, тело не выполнится ни разу.
        ```
    *   **`for` (Цикл со счетчиком/инициализацией):**
        ```c
        for (инициализация; условие; итерация) {
            // Операторы тела цикла
        }
        // Пример:
        // for (int i = 0; i < 10; i++) { printf("%d ", i); } 
        ```
    *   **`do-while` (Цикл с постусловием):**
        ```c
        do {
            // Операторы тела цикла
        } while (условие);
        // Тело цикла выполнится хотя бы один раз, затем проверяется условие.
        ```
