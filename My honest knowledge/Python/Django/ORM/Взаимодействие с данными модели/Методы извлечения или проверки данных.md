1. **`first()`:**
    
    Получает первый объект выборки.
    
    Пример использования:
    
    ```python
    MyModel.objects.filter(...).first()
    ```
    
    **Возвращает:** объект модели или `None`, если объекты не найдены.
    
2. `last()`:
    
    Получает последний объект выборки.
    
    Пример использования:
    
    ```python
    MyModel.objects.filter(...).last()
    ```
    
    **Возвращает:** объект модели или `None`, если объекты не найдены.
    
3. **`earliest(*fields)`**:
    
    Получает объект с наименьшим значением для указанных полей дат.
    
    Можно использовать `-` для обратного результата (удобно, если нужно использовать несколько полей в методе и первое должно быть отсортированно по возрастанию, а второе по убыванию).
    
    Также если в Meta вашей модели задан `get_latest_by`, вы можете опустить любые аргументы в earliest() или latest(). По умолчанию будут использоваться поля, указанные в get_latest_by.
    
    Пример использования:
    
    ```python
    MyModel.objects.earliest('date_field')
    ```
    
    **Возвращает:** объект модели или вызывает исключение `DoesNotExists`, если ни один объект не соответствует заданным параметрам.
    
4. **`latest(*fields)`**:
    
    Получает объект с наибольшим значением для указанных полей дат.
    
    Пример использования:
    
    ```python
    MyModel.objects.latest('date_field')
    ```
    
    **Возвращает:** объект модели или вызывает исключение `DoesNotExists`, если ни один объект не соответствует заданным параметрам.
    
    >[!warning] 
    >`earliest()` и `latest()` могут возвращать записи, для которых нет даты (`NULL` в поле даты).
    >
    >Поскольку упорядочивание делегируется базе данных, результаты по полям, допускающим отсутствие значения, могут быть упорядочены по-разному, если вы используете разные базы данных. Например, PostgreSQL и MySQL сортируют `NULL` значения так, как будто они выше, чем `NOT NULL`, а SQLite делает наоборот.
    >
    >Вам может понадобиться отфильтровать `NULL` значения:
    >
    >`Entry.objects.filter(pub_date__isnull=False).latest("pub_date")`
    
    
5. **`get_previous_by(field_name, kwargs)`**:
    
    Получает объект, предшествующий текущему объекту, основываясь на значении указанного поля даты/времени.
    
    Если поле даты `null=True`, то этот метод не будет существовать для данного поля.
    
    Оба метода могут принимать дополнительные ключевые аргументы, которые могут использоваться для фильтрации результатов.
    
    Если значения даты или времени идентичны для нескольких объектов, эти методы используют первичный ключ как дополнительный критерий для разрешения конфликта. Это гарантирует, что не будет пропущено или дублировано записей.
    
    Пример использования:
    
    ```python
    my_object.get_previous_by_date_field()
    ```
    
    **Возвращает:** объект модели или вызывает `DoesNotExist`, если объект не найден.
    
6. **`get_next_by(field_name, kwargs)`:**
    
    Получает объект, следующий за текущим объектом, основываясь на значении указанного поля.
    
    Пример использования:
    
    ```python
    my_object.get_next_by_date_field()
    ```
    
    **Возвращает:** объект модели или вызывает `DoesNotExist`, если объект не найден.
    
7. **`exists()`:**
    
    Проверяет, существуют ли объекты, удовлетворяющие определенным условиям фильтрации.
    
    Вместо использования `if some_queryset:`, который вернет `True`, если QuerySet не пуст, использование `if some_queryset.exists():` будет чуть быстрее, особенно при работе с большими QuerySet'ами.
    
    Пример использования:
    
    ```python
    MyModel.objects.filter(...).exists()
    ```
    
    **Возвращает:** `True`, если QuerySet содержит какие-либо результаты, и `False`, если нет.
    
8. **`count()`:**
    
    Подсчитывает количество объектов, удовлетворяющих определенным условиям фильтрации.
    
    Пример использования:
    
    ```python
    MyModel.objects.filter(...).count()
    ```
    
    **Возвращает:** количество объектов в результате запроса.
    
    >[!warning]
    >Вызов `count()` выполняет `SELECT COUNT(*)` за кулисами, поэтому вы всегда должны использовать `count()`, а не загружать все записи в объекты Python и вызывать `len()` для результата (если только вам не нужно загружать объекты в память, в этом случае `len()` будет быстрее).