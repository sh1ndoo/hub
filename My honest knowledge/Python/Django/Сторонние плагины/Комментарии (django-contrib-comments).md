

---

**django-contrib-comments** — это официальное приложение комментариев для Django, которое было выделено из основного фреймворка в отдельный пакет, начиная с Django 1.8. Оно предоставляет базовую, гибкую и универсальную систему для добавления комментариев практически к любой модели в вашем Django проекте.

**Основная идея:**

Приложение `django-contrib-comments` использует фреймворк [Content Types](https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/) (`django.contrib.contenttypes`) и Generic Relations для того, чтобы ассоциировать модель комментария (`Comment`) с *любым* другим объектом модели в вашей базе данных (например, статьей, фотографией, продуктом и т.д.). Это делает его очень гибким.

**Возможности "из коробки":**

*   Создание и сохранение комментариев.
*   Отображение списка комментариев для конкретного объекта.
*   Форма для добавления нового комментария.
*   Базовая модерация (хотя и довольно простая).
*   Поддержка как аутентифицированных, так и анонимных пользователей.

**Что оно НЕ делает "из коробки":**

*   **Древовидные (threaded) комментарии:** Комментарии отображаются плоским списком. Нет встроенной логики для ответов на конкретные комментарии и построения веток.
*   **Продвинутая модерация:** Нет встроенной системы автоматического определения спама (кроме интеграции со сторонними сервисами типа Akismet), нет сложной системы правил.
*   **Уведомления:** Нет автоматических уведомлений по email о новых комментариях.
*   **Лайки/Дизлайки/Голосования:** Нет встроенной системы оценки комментариев.
*   **Rich Text/Markdown:** Поле комментария - обычный текст.

**Зачем его использовать?**

*   Это официальное, хорошо протестированное и поддерживаемое решение.
*   Оно простое для базовых нужд и хорошо интегрируется с Django.
*   Является отличной основой для дальнейшего расширения (например, с помощью `django-comments-xtd`) или кастомизации.

---

### 1. Установка

Установка стандартна для пакетов Python:

1.  **Установите пакет:**

    ```bash
    pip install django-contrib-comments
    ```
    (Используйте `pip3` если нужно).

2.  **Добавьте необходимые приложения в `settings.py`:**

    В список `INSTALLED_APPS` добавьте следующие приложения:

    ```python
    # settings.py

    INSTALLED_APPS = [
        # Обязательные для Django приложения
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes', # <--- Нужно для комментариев
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'django.contrib.sites', # <--- Нужно для комментариев

        # Ваше приложение с моделями, к которым будут прикреплены комментарии
        'your_app_name', # Замените на имя вашего приложения

        # Приложение комментариев
        'django_comments', # <--- Само приложение комментариев
        # Возможно, другие сторонние приложения, если используете их
        # 'django_comments_xtd', # Например, если расширяете функционал
    ]

    # ... другие настройки
    ```    *   `django.contrib.contenttypes`: Предоставляет фреймворк для работы с моделями как "типами контента".
    *   `django.contrib.sites`: Позволяет привязать комментарии к конкретному сайту, если у вас их несколько на одной инсталляции Django. **Это приложение обязательно для `django-contrib-comments`.**

3.  **Настройте `SITE_ID`:**

    В `settings.py` вам нужно указать идентификатор сайта. Если у вас только один сайт, просто добавьте:

    ```python
    # settings.py

    SITE_ID = 1
    ```
    Если вы не уверены, какой у вас `SITE_ID` или хотите создать новый сайт, вы можете сделать это через административную панель Django (`/admin/sites/`).

---

### 2. Настройка базы данных (Миграции)

После добавления `django_comments` (и `django.contrib.contenttypes`, `django.contrib.sites`) в `INSTALLED_APPS`, вам нужно создать и применить миграции для создания таблиц, необходимых этим приложениям:

```bash
python manage.py migrate
```

Эта команда создаст, среди прочего, таблицы:
*   `django_content_type` (для Content Types)
*   `django_site` (для Sites)
*   `django_comments` (для хранения комментариев)

---

### 3. Интеграция с вашей моделью

Теперь, когда приложение установлено и настроено, вам нужно добавить функционал комментариев к вашей модели. Это делается в основном на уровне **шаблонов**.

Предположим, у вас есть модель `Article` в приложении `blog`, и вы хотите добавить комментарии к детальной странице статьи.

1.  **Получите объект модели в представлении:**

    Ваше представление (`DetailView` или function-based view) должно получить конкретный экземпляр модели, к которому будут привязаны комментарии.

    ```python
    # blog/views.py (Пример для DetailView)
    from django.views.generic import DetailView
    from .models import Article

    class ArticleDetailView(DetailView):
        model = Article
        template_name = 'blog/article_detail.html'
        context_object_name = 'article' # Передаем объект статьи под именем 'article'
    ```

2.  **Отобразите комментарии и форму в шаблоне:**

    В шаблоне детальной страницы (`blog/article_detail.html`) используйте специальные теги шаблона, предоставляемые `django-contrib-comments`.

    ```html
    {# blog/article_detail.html #}
    {% extends 'base.html' %}
    {% load comments %} {# Загружаем теги комментариев #}

    {% block content %}
        <h1>{{ article.title }}</h1>
        <p>{{ article.body }}</p>

        <h2>Комментарии</h2>

        {# Отображает список комментариев для объекта 'article' #}
        {# Использует шаблон comments/list.html по умолчанию #}
        {% render_comment_list for article %}

        <h3>Оставить комментарий</h3>

        {# Отображает форму комментария для объекта 'article' #}
        {# Использует шаблон comments/form.html по умолчанию #}
        {% render_comment_form for article %}

    {% endblock %}
    ```

*   **`{% load comments %}`:** Необходимо для использования тегов комментариев.
*   **`{% render_comment_list for [object] %}`:** Этот тег берет объект (в данном случае `article`), находит все комментарии, привязанные к нему через Content Types, и рендерит их с использованием шаблона `comments/list.html`.
*   **`{% render_comment_form for [object] %}`:** Этот тег берет объект (`article`), создает форму комментария, привязанную к этому объекту, и рендерит её с использованием шаблона `comments/form.html`.

---

### 4. Конфигурация URL-адресов

Приложение `django-contrib-comments` предоставляет свои собственные представления (views) для обработки отправки формы комментария, предварительного просмотра и т.д. Вам нужно подключить их URL-адреса в вашем главном файле `urls.py`.

```python
# project_name/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('comments/', include('django_comments.urls')), # <--- Подключаем URL-адреса комментариев
    path('', include('blog.urls')), # Подключаем URL-адреса вашего приложения, где статьи
    # ... другие URL
]
```
Теперь URL-адреса вроде `/comments/post/` (для отправки формы) будут доступны.

---

### 5. Ключевые концепции

*   **Модель `Comment`:** Главная модель приложения находится в `django_comments.models.Comment`. Она содержит поля:
    *   `content_type` (ForeignKey к `ContentType`)
    *   `object_pk` (CharField) - строковое представление первичного ключа комментируемого объекта.
    *   `site` (ForeignKey к `Site`)
    *   `user` (ForeignKey к `User` или None) - автор комментария (если аутентифицирован).
    *   `user_name`, `user_email`, `user_url` - для анонимных комментариев.
    *   `comment` (TextField) - текст комментария.
    *   `submit_date` (DateTimeField) - дата и время отправки.
    *   `ip_address` (GenericIPAddressField)
    *   `is_public` (BooleanField) - опубликован ли комментарий.
    *   `is_removed` (BooleanField) - удален ли комментарий (для "мягкого" удаления).
*   **Content Types и Generic Relations:** Механизм, который позволяет полю `content_type` и `object_pk` в модели `Comment` ссылаться на любой объект любой модели. Это позволяет вам прикреплять комментарии к статьям, фотографиям, видео и т.д., используя одну и ту же таблицу комментариев.
*   **Сигналы:** Приложение отправляет сигналы (`comment_was_posted`, `comment_will_be_posted`), на которые вы можете подписаться в своем коде для выполнения действий, например, отправки уведомлений или дополнительной модерации.

---

### 6. Кастомизация

Самая частая кастомизация `django-contrib-comments` - это изменение внешнего вида и поведения формы и списка комментариев.

#### 6.1 Кастомизация шаблонов

Вы можете легко переопределить стандартные шаблоны, используемые тегами `{% render_comment_list %}` и `{% render_comment_form %}`. Для этого создайте соответствующую структуру директорий в директории `templates` вашего приложения или проекта:

*   `templates/comments/list.html`: Шаблон для отображения списка комментариев.
*   `templates/comments/form.html`: Шаблон для отображения формы комментария.
*   `templates/comments/base.html`: Базовый шаблон, от которого могут наследоваться другие шаблоны комментариев.
*   `templates/comments/preview.html`: Шаблон для страницы предварительного просмотра комментария.
*   `templates/comments/removed.html`: Шаблон для страницы после удаления комментария.

Ваши файлы в этой структуре будут иметь приоритет над файлами из установленного пакета `django-contrib-comments`.

**Пример переопределения `templates/comments/list.html`:**

```html
{# templates/comments/list.html #}
{# Этот шаблон получает переменную comment_list, которая содержит QuerySet комментариев #}

{% if comment_list %}
    <ul>
        {% for comment in comment_list %}
            <li>
                <p>От:
                    {% if comment.user %}
                        {{ comment.user.username }}
                    {% else %}
                        {{ comment.user_name|default:"Аноним" }}
                    {% endif %}
                    ({{ comment.submit_date|date:"d.m.Y H:i" }})
                </p>
                <p>{{ comment.comment|linebreaks }}</p> {# Отображаем текст, сохраняя переносы строк #}
            </li>
        {% endfor %}
    </ul>
{% else %}
    <p>Пока нет комментариев.</p>
{% endif %}
```

#### 6.2 Кастомизация формы

Вы можете создать свою собственную форму, которая наследуется от `django_comments.forms.CommentForm`, чтобы добавить поля, изменить виджеты или добавить валидацию.

```python
# your_app/forms.py
from django_comments.forms import CommentForm
from django import forms

class MyCommentForm(CommentForm):
    # Добавляем новое поле
    rating = forms.IntegerField(min_value=1, max_value=5, required=False)

    # Можно изменить виджеты или метки существующих полей
    user_name = forms.CharField(label="Ваше имя", max_length=50)

    # Можно добавить кастомную валидацию
    def clean_comment(self):
        comment = self.cleaned_data['comment']
        if "плохое слово" in comment.lower():
            raise forms.ValidationError("Комментарий содержит запрещенные слова.")
        return comment
```

Чтобы Django использовал вашу кастомную форму, у вас есть два основных варианта:

1.  **Указать форму в URL-конфигурации:**

    ```python
    # project_name/urls.py
    from django.urls import path, include
    from your_app.forms import MyCommentForm # Импортируем вашу форму

    urlpatterns = [
        # ... другие URL
        path('comments/', include('django_comments.urls.comments', namespace='comments')), # Подключаем URL с пространством имен
        # Переопределяем URL для отправки, указывая нашу форму
        path('comments/post/', 'django_comments.views.comments.post_comment', {'form_class': MyCommentForm}, name='comments-post-comment'),

        # Также можно переопределить URL для предварительного просмотра, если нужно
        # path('comments/preview/', 'django_comments.views.comments.preview_comment', {'form_class': MyCommentForm}, name='comments-preview-comment'),
        # ...
    ]
    ```
    *   **Важно:** Вам нужно будет немного изменить строку `include`, чтобы использовать `django_comments.urls.comments` и подключить только views, связанные с формой и постингом, чтобы не создавать дубликаты URL.
    *   **Обратите внимание:** Здесь используется старый синтаксис URL-адресов (`'view_module.view_function'`, `{}` для kwargs). В современном Django предпочтительнее использовать `path` с именованными аргументами. Возможно, придется найти примеры адаптации этого под новый синтаксис или использовать другой подход.

2.  **Переопределить шаблон формы (`comments/form.html`)** и вручную создать экземпляр вашей формы в этом шаблоне, передавая ей необходимые данные (это более сложный путь).

#### 6.3 Кастомизация модели

В редких случаях вам может понадобиться создать свою собственную модель комментария, наследуя её от `django_comments.models.Comment`. Это делается, если вы хотите добавить поля, которые должны храниться непосредственно в таблице комментариев (например, поле для модерационного статуса или рейтинг).

```python
# your_app/models.py
from django_comments.models import Comment
from django.db import models

class MyComment(Comment):
    # Дополнительные поля
    moderation_status = models.CharField(
        max_length=20,
        choices=[('pending', 'В ожидании'), ('approved', 'Одобрено'), ('rejected', 'Отклонено')],
        default='pending'
    )
    # Допустим, вы не добавили рейтинг в форму, а решили хранить его тут
    rating = models.PositiveIntegerField(null=True, blank=True)

    class Meta:
        # Важно: указать, что эта модель абстрактна в базе данных комментариев,
        # но является конкретной вашей моделью.
        # Abstract=True здесь не подходит. Нужна особая мета-опция.
        # В документации django-contrib-comments описано, как правильно это настроить.
        # Обычно это делается путем установки settings.COMMENTS_APP
        # и наследования от django_comments.models.Comment
        pass # Мета-опции для прокси или multi-table inheritance здесь не нужны напрямую.

# settings.py
COMMENTS_APP = 'your_app' # Указывает Django использовать модели и формы из вашего приложения

```

**Важно:** Если вы создаете кастомную модель комментария, вы должны указать Django использовать её, установив настройку `COMMENTS_APP` в `settings.py` на имя вашего приложения, содержащего кастомную модель. После этого вам нужно будет выполнить `makemigrations your_app` и `migrate`.

#### 6.4 Кастомизация представлений

Вы можете переопределить представления, которые обрабатывают отправку и предварительный просмотр комментариев. Это более сложный уровень кастомизации, который может понадобиться, если стандартные представления не соответствуют вашей логике (например, для выполнения сложных проверок или изменения процесса перенаправления).

---

### 7. Модерация

`django-contrib-comments` включает базовый модуль модерации (`django_comments.moderation`).

1.  **Создайте класс модерации:**

    ```python
    # your_app/moderator.py
    from django_comments.moderation import CommentModerator, moderator
    from .models import Article # Импортируйте модель, которую хотите модерировать

    class ArticleCommentModerator(CommentModerator):
        # Модерация может быть автоматической
        auto_moderate_field = 'submit_date' # Поле, которое определяет "возраст" объекта для модерации
        moderate_after = 1 # Модерировать вручную комментарии, оставленные через 1 день после submit_date статьи

        # Или модерация может требовать подтверждения (для анонимов по email)
        # enable_flags = True # Позволяет пользователям помечать комментарии
        # email_notification = True # Отправлять письмо модераторам о новых комментариях

        # Закрыть комментарии для объектов, где поле 'closed' == True
        close_comments_field = 'closed'
        close_comments_after = 30 # Закрыть комментарии через 30 дней после submit_date

    # Зарегистрируйте вашу модель и класс модерации
    moderator.register(Article, ArticleCommentModerator)
    ```

2.  **Зарегистрируйте файл модерации:**

    В файле `__init__.py` вашего приложения (`your_app/__init__.py`), добавьте строку для импорта вашего файла модерации. Это гарантирует, что классы модерации будут зарегистрированы при запуске Django.

    ```python
    # your_app/__init__.py
    import your_app.moderator # Убедитесь, что ваш файл модерации импортируется
    ```

Система модерации довольно простая. Для более сложной логики вам, возможно, придется использовать сигналы или интегрироваться с внешними спам-фильтрами.

---

### 8. Анонимные VS Аутентифицированные комментарии

Приложение автоматически определяет, вошел ли пользователь в систему.

*   **Аутентифицированные пользователи:** Для них поля имени, email и URL в форме комментария скрываются или становятся нередактируемыми (используются данные из профиля пользователя).
*   **Анонимные пользователи:** Для них поля имени, email и URL отображаются в форме, и они обязательны по умолчанию.

Вы можете управлять этим поведением. Например, чтобы **запретить анонимные комментарии**, добавьте в `settings.py`:

```python
# settings.py
COMMENTS_ALLOW_ANONYMOUS = False # По умолчанию True
```

---

### 9. Дальнейшие шаги (после `django-contrib-comments`)

Если базовых функций `django-contrib-comments` вам не хватает, следующий логичный шаг — это использование **`django-comments-xtd`**. Как упоминалось ранее, он строится поверх `django-contrib-comments` и добавляет древовидные комментарии, email-уведомления, голосование и другие современные функции.

---

### 10. Итог

`django-contrib-comments` — это отличный, надежный фундамент для добавления комментариев в ваш Django проект. Он использует стандартные механизмы Django (Content Types, Generic Relations), что делает его гибким и простым для базового использования. Хотя он не предоставляет всех функций современных систем комментариев "из коробки", его легко кастомизировать на уровне шаблонов и форм, а также расширять с помощью других приложений, таких как `django-comments-xtd`. Всегда начинайте с официальной документации для самой актуальной и полной информации.