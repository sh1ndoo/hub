
*   **Анонимная функция `lambda`:**
	*   Создает небольшую анонимную функцию.
	*   Синтаксис: `lambda аргументы: выражение`
	*   Возвращает результат `выражения`.
	*   Ограничения: только одно выражение, не может содержать сложные инструкции (циклы, `if` как инструкция, `try`, etc.).
	*   Часто используется там, где нужна короткая функция (например, как `key` для `sort()`, `sorted()`, `min()`, `max()` или в `map()`, `filter()`).
	*   Пример:
		```python
		# Эквивалентно def square(x): return x**2
		square = lambda x: x**2 
		print(square(5)) # Вывод: 25

		points = [(1, 5), (3, 2), (2, 8)]
		# Сортировка по второму элементу кортежа
		points.sort(key=lambda point: point[1]) 
		print(points) # Вывод: [(3, 2), (1, 5), (2, 8)]
		```
*   **Функция `map()`:**
	*   `map(function, iterable, ...)`
	*   Применяет `function` к каждому элементу `iterable` (или нескольким `iterable`, если `function` принимает несколько аргументов).
	*   Возвращает *итератор* (`map object`), содержащий результаты.
	*   Пример 1:
		```python
		a = ['hello', 'hi', 'good morning'] 
		# Применить str.upper к каждому элементу списка a
		b_iterator = map(str.upper, a) 
		b_list = list(b_iterator) # Преобразовать итератор в список
		print(b_list) # Вывод: ['HELLO', 'HI', 'GOOD MORNING']
		```
	*   Пример 2 (несколько итераторов):
		```python
		nums1 = [1, 2, 3]
		nums2 = [4, 5, 6] 
		nums3 = [7, 8, 9]  
		# Сложить соответствующие элементы из трех списков
		result = map(lambda x, y, z: x + y + z, nums1, nums2, nums3)
		print(list(result)) # Вывод: [12, 15, 18]
		```
*   **Функция `filter()`:**
	*   `filter(function, iterable)`
	*   Фильтрует элементы `iterable`, оставляя только те, для которых `function` возвращает `True`. Если `function` это `None`, остаются только истинные элементы.
	*   Возвращает *итератор* (`filter object`).
	*   Пример:
		```python
		def is_greater_than_10(x):     
			return x > 10   
		
		numbers = [14, 0, 5, -79, 645, 7952, 18, 0, -192, 471]
		# Отфильтровать числа > 10
		numbers_gt_10_iterator = filter(is_greater_than_10, numbers)
		numbers_gt_10_list = list(numbers_gt_10_iterator)
		print(numbers_gt_10_list) # Вывод: [14, 645, 7952, 18, 471]
		
		# Пример с None
		mixed = [0, 1, '', 'hello', None, True, False]
		truthy_items = list(filter(None, mixed))
		print(truthy_items) # Вывод: [1, 'hello', True]
		```
*   **Функция `zip()`:**
	*   `zip(*iterables)`
	*   Объединяет элементы из нескольких итерируемых последовательностей в кортежи.
	*   Возвращает *итератор* (`zip object`).
	*   Итератор останавливается, когда заканчивается *самая короткая* из переданных последовательностей.
	*   Пример 1:
		```python
		ids = [1, 2, 3, 4] 
		leaders = ['Elon Musk', 'Tim Cook', 'Bill Gates', 'Yang Zhou'] 
		countries = ('Australia', 'USA') # Короче других
		records_iterator = zip(ids, leaders, countries)  
		records_list = list(records_iterator)  
		print(records_list)  
		# Вывод: [(1, 'Elon Musk', 'Australia'), (2, 'Tim Cook', 'USA')] 
		```
	*   Пример 2 (создание словаря):
		```python
		employee_numbers = [2, 9, 18]
		employee_names = ["Valentin", "Leonti", "Andrew"]  
		
		numbers_to_names = dict(zip(employee_numbers, employee_names)) 
		names_to_numbers = dict(zip(employee_names, employee_numbers))
		
		print(numbers_to_names)  
		# Вывод: {2: 'Valentin', 9: 'Leonti', 18: 'Andrew'}
		print(names_to_numbers)
		# Вывод: {'Valentin': 2, 'Leonti': 9, 'Andrew': 18}
		```
*   **`zip_longest()` (из модуля `itertools`):**
	*   `itertools.zip_longest(*iterables, fillvalue=None)`
	*   Работает как `zip()`, но итерирует до конца *самой длинной* последовательности, заполняя недостающие значения значением `fillvalue`.
	*   Пример:
		```python
		from itertools import zip_longest
		
		ids = [1, 2, 3, 4] 
		leaders = ['Elon Musk', 'Tim Cook', 'Bill Gates', 'Yang Zhou']
		countries = ('Australia', 'USA')
		
		records_longest = zip_longest(ids, leaders, countries, fillvalue='Unknown')
		print(list(records_longest)) 
		# Вывод: 
		# [(1, 'Elon Musk', 'Australia'),
		#  (2, 'Tim Cook', 'USA'),
		#  (3, 'Bill Gates', 'Unknown'), 
		#  (4, 'Yang Zhou', 'Unknown')]
		```
*   **Функция `isinstance()`:**
	*   `isinstance(object, classinfo)`
	*   Проверяет, является ли `object` экземпляром класса `classinfo` или его подкласса.
	*   `classinfo` может быть одним классом или кортежем классов.
	*   Предпочтительнее, чем прямое сравнение типов с `type()`, так как учитывает наследование.
	*   Пример:
		```python
		a = [5, 3, 'hello', [3, 4], ' world', [5], 10.5] 
		sum_nums = 0 
		for i in a:
			# Проверить, является ли i целым или вещественным числом
			if isinstance(i, (int, float)): 
				sum_nums += i 
		print(sum_nums)  # Вывод: 18.5
		```
*   **Функции `all()` и `any()`:**
	*   **`all(iterable)`:** Возвращает `True`, если *все* элементы `iterable` истинны (или если `iterable` пуст).
		```python
		print(all([True, 1, "hello"])) # True
		print(all([True, 0, "hello"])) # False (из-за 0)
		print(all([])) # True
		```
	*   **`any(iterable)`:** Возвращает `True`, если *хотя бы один* элемент `iterable` истинен. Возвращает `False`, если `iterable` пуст.
		```python
		print(any([False, 0, "hello"])) # True (из-за "hello")
		print(any([False, 0, ""])) # False
		print(any([])) # False
		```*   **Создание функции (`def`):**
*   Синтаксис:
	```python
	def имя_функции(параметр1, параметр2=значение_по_умолчанию, *args, **kwargs):
		"""Докстринг: Описание того, что делает функция."""
		# Тело функции (инструкции)
		результат = ...
		return результат # Необязательно, если функция ничего не возвращает (вернет None)
	```
*   Вызов: `имя_функции(аргумент1, аргумент2, ...)` или `print(имя_функции(...))`
*   Пример:
	```python
	def factorial(n: int) -> int:
		"""Вычисляет факториал целого неотрицательного числа n."""
		if not isinstance(n, int) or n < 0:
			raise ValueError("Факториал определен только для целых неотрицательных чисел")
		pr = 1     
		for i in range(1, n + 1): # Используем range(1, ...) т.к. умножение на 0 не нужно
			pr *= i
		return pr # Возвращаем результат, а не печатаем

	try:
		print(f"Factorial 3 = {factorial(3)}") # -> 6
		print(f"Factorial 5 = {factorial(5)}") # -> 120
		print(f"Factorial 0 = {factorial(0)}") # -> 1
		# print(f"Factorial -1 = {factorial(-1)}") # Вызовет ValueError
	except ValueError as e:
		print(e)
